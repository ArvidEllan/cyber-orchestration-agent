/**
 * Vulnerability Checker
 * Identifies vulnerabilities in AWS resources using CVE databases and threat intelligence
 */

import {
  Component,
  Vulnerability,
  Severity,
  ThreatIntelligence,
  Resource,
} from '../types';

export interface CVEData {
  cveId: string;
  description: string;
  severity: string;
  cvssScore: number;
  publishedDate: string;
  lastModifiedDate: string;
  references: string[];
  affectedVersions: string[];
}

export interface LambdaRuntime {
  runtime: string;
  endOfLifeDate: Date;
  status: 'active' | 'deprecated' | 'eol';
}

export class VulnerabilityChecker {
  private eolRuntimes: Map<string, LambdaRuntime>;
  private cveCache: Map<string, CVEData[]>;

  constructor() {
    this.eolRuntimes = this.initializeEOLRuntimes();
    this.cveCache = new Map();
  }

  /**
   * Check component for vulnerabilities
   */
  async checkVulnerabilities(component: Component): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // Check for EOL Lambda runtimes
    if (component.type === 'lambda' || component.type === 'Lambda::Function') {
      const eolVulns = this.checkLambdaRuntime(component);
      vulnerabilities.push(...eolVulns);
    }

    // Check for EC2 AMI vulnerabilities
    if (component.type === 'ec2' || component.type === 'EC2::Instance') {
      const amiVulns = await this.checkEC2AMI(component);
      vulnerabilities.push(...amiVulns);
    }

    // Check for container image vulnerabilities
    if (
      component.type === 'container' ||
      component.type === 'EKS::Container' ||
      component.type === 'ECS::Container'
    ) {
      const containerVulns = await this.checkContainerImage(component);
      vulnerabilities.push(...containerVulns);
    }

    // Check for known CVEs
    const cveVulns = await this.checkCVEs(component);
    vulnerabilities.push(...cveVulns);

    return vulnerabilities;
  }

  /**
   * Check Lambda runtime for EOL status
   */
  private checkLambdaRuntime(component: Component): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];
    const runtime = component.version || component.name;

    const runtimeInfo = this.eolRuntimes.get(runtime);

    if (runtimeInfo && runtimeInfo.status !== 'active') {
      const severity =
        runtimeInfo.status === 'eol' ? Severity.CRITICAL : Severity.HIGH;

      vulnerabilities.push({
        cve: 'EOL-RUNTIME',
        component: component.name,
        version: runtime,
        severity,
        exploitability: runtimeInfo.status === 'eol' ? 8 : 5,
        threatIntel: {
          source: 'AWS Lambda Runtime Support',
          description: `Lambda runtime ${runtime} is ${runtimeInfo.status === 'eol' ? 'end-of-life' : 'deprecated'}`,
          indicators: [runtime],
          references: [
            'https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html',
          ],
          lastUpdated: new Date(),
        },
      });
    }

    return vulnerabilities;
  }

  /**
   * Check EC2 AMI for vulnerabilities
   */
  private async checkEC2AMI(component: Component): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // Extract AMI ID from component
    const amiId = this.extractAMIId(component);
    if (!amiId) {
      return vulnerabilities;
    }

    // Check for known vulnerable AMIs
    const knownVulnerableAMIs = this.getKnownVulnerableAMIs();

    if (knownVulnerableAMIs.has(amiId)) {
      const vulnInfo = knownVulnerableAMIs.get(amiId)!;

      vulnerabilities.push({
        cve: vulnInfo.cve,
        component: component.name,
        version: amiId,
        severity: this.mapCVSSSeverity(vulnInfo.cvssScore),
        exploitability: this.calculateExploitability(vulnInfo.cvssScore),
        threatIntel: {
          source: 'NVD / AWS Security Bulletins',
          description: vulnInfo.description,
          indicators: [amiId],
          references: vulnInfo.references,
          lastUpdated: new Date(vulnInfo.lastModifiedDate),
        },
      });
    }

    return vulnerabilities;
  }

  /**
   * Check container image for vulnerabilities
   */
  private async checkContainerImage(
    component: Component
  ): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // Extract image name and tag
    const imageInfo = this.extractImageInfo(component);
    if (!imageInfo) {
      return vulnerabilities;
    }

    // Check for known vulnerable images
    const knownVulnerableImages = this.getKnownVulnerableImages();

    const imageKey = `${imageInfo.name}:${imageInfo.tag}`;

    if (knownVulnerableImages.has(imageKey)) {
      const vulnInfo = knownVulnerableImages.get(imageKey)!;

      vulnerabilities.push({
        cve: vulnInfo.cve,
        component: component.name,
        version: imageInfo.tag,
        severity: this.mapCVSSSeverity(vulnInfo.cvssScore),
        exploitability: this.calculateExploitability(vulnInfo.cvssScore),
        threatIntel: {
          source: 'Container Security Databases',
          description: vulnInfo.description,
          indicators: [imageKey],
          references: vulnInfo.references,
          lastUpdated: new Date(vulnInfo.lastModifiedDate),
        },
      });
    }

    return vulnerabilities;
  }

  /**
   * Check for CVEs affecting the component
   */
  private async checkCVEs(component: Component): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // Check cache first
    const cacheKey = `${component.name}:${component.version}`;
    if (this.cveCache.has(cacheKey)) {
      const cveData = this.cveCache.get(cacheKey)!;
      return this.convertCVEDataToVulnerabilities(cveData, component);
    }

    // In a real implementation, this would query NVD API
    // For now, return empty array
    return vulnerabilities;
  }

  /**
   * Query NVD API for CVEs (placeholder)
   */
  private async queryNVDAPI(
    componentName: string,
    version: string
  ): Promise<CVEData[]> {
    // This is a placeholder. In a real implementation, this would:
    // 1. Make HTTP request to NVD API
    // 2. Parse the response
    // 3. Filter by component name and version
    // 4. Return CVE data

    // Example NVD API endpoint:
    // https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch=${componentName}

    return [];
  }

  /**
   * Convert CVE data to vulnerabilities
   */
  private convertCVEDataToVulnerabilities(
    cveData: CVEData[],
    component: Component
  ): Vulnerability[] {
    return cveData.map((cve) => ({
      cve: cve.cveId,
      component: component.name,
      version: component.version,
      severity: this.mapCVSSSeverity(cve.cvssScore),
      exploitability: this.calculateExploitability(cve.cvssScore),
      threatIntel: {
        source: 'National Vulnerability Database',
        description: cve.description,
        indicators: [cve.cveId],
        references: cve.references,
        lastUpdated: new Date(cve.lastModifiedDate),
      },
    }));
  }

  /**
   * Initialize EOL Lambda runtimes
   */
  private initializeEOLRuntimes(): Map<string, LambdaRuntime> {
    const runtimes = new Map<string, LambdaRuntime>();

    // EOL runtimes
    runtimes.set('nodejs12.x', {
      runtime: 'nodejs12.x',
      endOfLifeDate: new Date('2023-03-31'),
      status: 'eol',
    });
    runtimes.set('nodejs10.x', {
      runtime: 'nodejs10.x',
      endOfLifeDate: new Date('2021-07-30'),
      status: 'eol',
    });
    runtimes.set('python3.6', {
      runtime: 'python3.6',
      endOfLifeDate: new Date('2022-07-18'),
      status: 'eol',
    });
    runtimes.set('python2.7', {
      runtime: 'python2.7',
      endOfLifeDate: new Date('2021-07-15'),
      status: 'eol',
    });
    runtimes.set('ruby2.5', {
      runtime: 'ruby2.5',
      endOfLifeDate: new Date('2021-07-30'),
      status: 'eol',
    });
    runtimes.set('dotnetcore2.1', {
      runtime: 'dotnetcore2.1',
      endOfLifeDate: new Date('2022-01-05'),
      status: 'eol',
    });

    // Deprecated runtimes
    runtimes.set('nodejs14.x', {
      runtime: 'nodejs14.x',
      endOfLifeDate: new Date('2023-11-27'),
      status: 'deprecated',
    });
    runtimes.set('python3.7', {
      runtime: 'python3.7',
      endOfLifeDate: new Date('2023-11-27'),
      status: 'deprecated',
    });

    // Active runtimes
    runtimes.set('nodejs18.x', {
      runtime: 'nodejs18.x',
      endOfLifeDate: new Date('2025-04-30'),
      status: 'active',
    });
    runtimes.set('nodejs20.x', {
      runtime: 'nodejs20.x',
      endOfLifeDate: new Date('2026-04-30'),
      status: 'active',
    });
    runtimes.set('python3.11', {
      runtime: 'python3.11',
      endOfLifeDate: new Date('2027-10-24'),
      status: 'active',
    });
    runtimes.set('python3.12', {
      runtime: 'python3.12',
      endOfLifeDate: new Date('2028-10-02'),
      status: 'active',
    });

    return runtimes;
  }

  /**
   * Get known vulnerable AMIs (placeholder)
   */
  private getKnownVulnerableAMIs(): Map<string, CVEData> {
    // This is a placeholder. In a real implementation, this would:
    // 1. Query AWS Security Bulletins
    // 2. Query vulnerability databases
    // 3. Return map of AMI IDs to CVE data

    return new Map();
  }

  /**
   * Get known vulnerable container images (placeholder)
   */
  private getKnownVulnerableImages(): Map<string, CVEData> {
    // This is a placeholder. In a real implementation, this would:
    // 1. Query container security databases
    // 2. Query Docker Hub / ECR for known vulnerabilities
    // 3. Return map of image:tag to CVE data

    return new Map();
  }

  /**
   * Extract AMI ID from component
   */
  private extractAMIId(component: Component): string | null {
    if (component.resource.properties.imageId) {
      return component.resource.properties.imageId;
    }

    if (component.resource.properties.ImageId) {
      return component.resource.properties.ImageId;
    }

    return null;
  }

  /**
   * Extract image info from component
   */
  private extractImageInfo(
    component: Component
  ): { name: string; tag: string } | null {
    let image = component.resource.properties.image ||
      component.resource.properties.Image;

    if (!image) {
      return null;
    }

    // Parse image string (e.g., "nginx:1.19" or "myrepo/nginx:1.19")
    const parts = image.split(':');
    if (parts.length === 2) {
      return {
        name: parts[0],
        tag: parts[1],
      };
    }

    return {
      name: image,
      tag: 'latest',
    };
  }

  /**
   * Map CVSS score to severity
   */
  private mapCVSSSeverity(cvssScore: number): Severity {
    if (cvssScore >= 9.0) return Severity.CRITICAL;
    if (cvssScore >= 7.0) return Severity.HIGH;
    if (cvssScore >= 4.0) return Severity.MEDIUM;
    if (cvssScore >= 0.1) return Severity.LOW;
    return Severity.INFO;
  }

  /**
   * Calculate exploitability score
   */
  private calculateExploitability(cvssScore: number): number {
    // Normalize CVSS score (0-10) to exploitability (0-10)
    // In a real implementation, this would consider:
    // - Attack complexity
    // - Privileges required
    // - User interaction
    // - Exploit availability

    return Math.round(cvssScore);
  }

  /**
   * Enrich finding with threat intelligence
   */
  async enrichWithThreatIntel(
    component: Component,
    vulnerability: Vulnerability
  ): Promise<Vulnerability> {
    // In a real implementation, this would:
    // 1. Query threat intelligence feeds
    // 2. Check for active exploits
    // 3. Get CISA KEV status
    // 4. Enrich with additional context

    // For now, return the vulnerability as-is
    return vulnerability;
  }

  /**
   * Check if CVE is in CISA KEV catalog (placeholder)
   */
  private async checkCISAKEV(cveId: string): Promise<boolean> {
    // This would query CISA Known Exploited Vulnerabilities catalog
    // https://www.cisa.gov/known-exploited-vulnerabilities-catalog

    return false;
  }

  /**
   * Get exploit availability (placeholder)
   */
  private async getExploitAvailability(cveId: string): Promise<string[]> {
    // This would check:
    // - Exploit-DB
    // - Metasploit modules
    // - Public PoCs on GitHub

    return [];
  }

  /**
   * Batch check vulnerabilities for multiple components
   */
  async batchCheckVulnerabilities(
    components: Component[]
  ): Promise<Map<string, Vulnerability[]>> {
    const results = new Map<string, Vulnerability[]>();

    // Process in parallel
    const promises = components.map(async (component) => {
      const vulnerabilities = await this.checkVulnerabilities(component);
      return { component, vulnerabilities };
    });

    const allResults = await Promise.all(promises);

    for (const { component, vulnerabilities } of allResults) {
      results.set(component.name, vulnerabilities);
    }

    return results;
  }

  /**
   * Get vulnerability statistics
   */
  getVulnerabilityStats(vulnerabilities: Vulnerability[]): {
    total: number;
    bySeverity: Record<Severity, number>;
    byComponent: Map<string, number>;
  } {
    const stats = {
      total: vulnerabilities.length,
      bySeverity: {
        [Severity.CRITICAL]: 0,
        [Severity.HIGH]: 0,
        [Severity.MEDIUM]: 0,
        [Severity.LOW]: 0,
        [Severity.INFO]: 0,
      },
      byComponent: new Map<string, number>(),
    };

    for (const vuln of vulnerabilities) {
      stats.bySeverity[vuln.severity]++;

      const count = stats.byComponent.get(vuln.component) || 0;
      stats.byComponent.set(vuln.component, count + 1);
    }

    return stats;
  }
}
